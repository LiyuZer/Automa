graph dfa_solver {
    memory {
        input_string : "baab";  // Global input string for DFA
    }

    transitions {
        Start Bab_graph => conditions: (), operations: (); // Start `bab_graph` validation
        Bab_graph Accept => conditions: (length(input_string) == 0), operations: (); // Accept if `bab_graph` completely consumes input
        Bab_graph Cd_graph => conditions: (!length(input_string) == 0), operations: (); // Continue to `cd_graph` if input remains

        Cd_graph Cd_graph => conditions: (cd_graph(input_string)), operations: (); // Recursive checks for `cd*`
        Cd_graph Accept => conditions: (length(input_string) == 0), operations: (); // Accept if `cd_graph` completes
    }
}

graph bab_graph {
    memory {
        input_string : "baab";
    }
    transitions {
        Start B => conditions: (head(input_string) == 'b'), operations: (input_string = tail(input_string));
        B B_1 => conditions: (head(input_string) == 'a'), operations: (input_string = tail(input_string));
        B_1 Accept => conditions: (head(input_string) == 'b'), operations: (input_string = tail(input_string));
    }
}

graph cd_graph {
    memory {
        input_string : "baab";
    }
    transitions {
        Start C => conditions: (head(input_string) == 'c'), operations: (input_string = tail(input_string));
        C Accept => conditions: (head(input_string) == 'd'), operations: (input_string = tail(input_string));
    }
}




/*Linked List*/


graph InsertLinkedList {
    memory => {
        val : "hey";             // Current node's value
        Next_Node : Next_Node_val; // Reference to the next node
        insert_val : "wassup";   // Value to insert
        insert_index : 5;        // Index where the new node will be inserted
        index : 0;               // Current index
    }

    transitions {
        // Case 1: Traverse to the next node if not at the insertion index and the next node exists
        Start Traverse => conditions: (index != insert_index && Next_Node != None),
                          operations: (index = index + 1, InsertLinkedList(Next_Node_val));

        // Case 2: Insert at the desired index when it is reached
        Traverse Insert => conditions: (index == insert_index),
                             operations: (Next_Node_val = memory {val = insert_val, Next_Node_val=Next_Node_val});

        // Case 3: Append at the end if the next node is None
        Traverse Append => conditions: (Next_Node == None),
                             operations: (Next_Node_val = memory {val = insert_val, Next_Node_val=None});
    }
}


/* Binary tree */


graph BST_Node {
    memory => {
        key : 0;                   // Key for this node
        left : None;               // Pointer to the left child (sub-graph)
        right : None;              // Pointer to the right child (sub-graph)
    }

    transitions {
        Start Insert_Left => conditions: (input < key && left == None),
                                operations: (left = memory {key = input, left = None, right = None});

        Start Traverse_Left => conditions: (input < key && left != None),
                                  operations: (BST_Node(left));

        Start Insert_Right => conditions: (input > key && right == None),
                                 operations: (right = memory {key = input, left = None, right = None});

        Start Traverse_Right => conditions: (input > key && right != None),
                                   operations: (BST_Node(right));

        Start Accept => conditions: (input == key),
                          operations: (); // No-op for duplicates
    }
}

graph BinarySearchTree inherits BST_Node {
    memory => {
        root : None;               // Root node of the tree
    }

    transitions {
        Start Initialize => conditions: (root == None),
                               operations: (root = memory {key = input, left = None, right = None});

        Start Traverse_Root => conditions: (root != None),
                                 operations: (BST_Node(root));

        Start Accept => conditions: (true),
                          operations: (); // Finish insertion
    }
}


/*We are going to go crazy with this one, this is an general dfa type that can be put together to create any regex expression */
graph regexNode{

memory {
    input_string : "hello";
    transitions_array : [transition tuples are here for the oeprations and conditions],
    next_node: [],
}

    transition{
    Start -> ProcessNode => conditions : (), operations : ();
    ProcessNode -> ProcessNode => conditions : (length(Next_Node) > 0), operations : (next_node = tail(next_node), transitions_array = tail(transitions_array));
    ProcessNode -> Accept => conditions: (transition_condition,regexNode(head(next_node))), operations();
    /*
    This way a Node has two paths that can be taken, one is a path that forwards its transitions, while another a path 
    that calls the dfa graph on the next node, if this coniditions is true then voila, we it will pass to the reject state  

    */


    }

}


/* We will now traverse a binary tree here*/
graph binaryTraversal{
    memory {
        LeftNode : Node,
        RightNode : Node,
        LeftNodeVisited = false:
        val : 5,
        ls : []
    }

    transition{
        Start ProcessNode => conditions : (), operations : (Append(ls, val));

        ProcessNode ProcessNode => conditions : (LeftNode!= None && !LeftNodeVisited, binaryTraversal(memory -> {LeftNode, ls : ls})), operations : (LeftNodeVisited = true); // This will call the graph again but with a new memory container having different nodes and the same list(all other valeus are set to the default )

        ProcessNode Accept => conditions : (RightNode!=None, binaryTraversal(memory -> {RightNode, ls : ls})), operations : ();

        ProcessNode Accept => conditions : (), operations : ();

    }
}


graphCreateString{
    memory{
        string : []
        length : graph{
            Start -> Accept => conditions : (), operations : (),
            return string.size()
        }
        concatenate : graph {
            memory{
                other_string : "",
                new_array = string + other_string // + for arrays is built in for speed
            }
            start -> Accept => conditions : () , operations : ();
            afterAccept(){
                return new_array;
            }
        }

    }


}