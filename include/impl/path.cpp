#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include "../core/operator.h"
#include "../core/path.h"
#include "../core/path.h"
#include "../core/memory.h"
#include "../core/graph.h"
#include "../../grammar/ast/ast_node.h"
#include "../typesdef/num.h"
#include "../typesdef/bool.h"
#include "../typesdef/char.h"


/* 
Evaluate the expression
As of not an expression can be a assignment, binary expression, unary expression, or a literal(term)
Conditions cannot be assignment expressions

The evaluation of the conditions of a transition will be done in the following way:-
    There will be a condition evaluation stack that will be used to evaluate the conditions
    Why is this the case? The reason is because at any point the condition might call a new graph 
    and thus a new path has to be generated by the operator. This results in a yield by the current path. 
    
    The operator will then run the current path, take  the output memory container and 
    then take the old path out of the pending stack and run it with this new memory container.

    This is a typical stack element:-
    {
        memory_container : memory_container
        type : ""  (Binary, Unary, Literal. Graph call)
        Stack_elem_ptr_ls : a vector of shared ptr to stack elements that may nor may not be evaluated 
    }
    This way we keep a track of the evaluation of the conditions. And we can backtrack if we need to, and start 
    evaluating the conditions again.

Note all operations are expressed by graphs, for example adding two ints(soon to be num) will be a graph,
the graph being an element of the memory container will be called and the two memory containers will be passed to it.
The graph will then return a new memory container with the result of the operation.
Simple as that.

These are the mapping for the operations to symbols. 
+ -> add
- -> subtract
* -> multiply
/ -> divide
% -> modulo
== -> equal
!= -> not_equal
< -> less
> -> greater
<= -> less_equal
>= -> greater_equal
&& -> and
|| -> or
! -> not
We will call these graphs from the memory_container(they are all graphs in the memory container)
*/

void Path :: set_memory(shared_ptr<AstNode> memory){
    // Loop through the memory defintions and set the memory container
    shared_ptr<memoryDef> memoryDef_ptr = dynamic_pointer_cast<memoryDef>(memory);
    vector<shared_ptr<AstNode> > variableDefinitions = memoryDef_ptr->get_variableDefinitions();

    for(auto var_def : variableDefinitions){
        shared_ptr var_def_ptr = dynamic_pointer_cast<variableDefintions>(var_def);
        string var_name = var_def_ptr->get_variableName();
        shared_ptr<AstNode> literal = var_def_ptr->get_literal();

        // Now we will go to the literal and set the memory container, first check the literal type
        if(dynamic_pointer_cast<stringLiteral>(literal)){
            shared_ptr<stringLiteral> stringLiteral_ptr = dynamic_pointer_cast<stringLiteral>(literal);
            
        }
        else if(dynamic_pointer_cast<integerLiteral>(literal)){
            // First get the integer literal
            shared_ptr<integerLiteral> integerLiteral_ptr = dynamic_pointer_cast<integerLiteral>(literal);
            string var_name = var_def_ptr->get_variableName();
            string integer_literal = integerLiteral_ptr->get_integerLiteral();
            cout<<"Integer Literal: "<<integer_literal<<endl;
            // Then take the integer literal create a integer object and set the memory container
            shared_ptr<Num> int_ptr = shared_ptr<Num>(new Num(integer_literal));
            memory_ptr->set_memory(var_name, int_ptr);
        }
        else if(dynamic_pointer_cast<charLiteral>(literal)){
            shared_ptr<charLiteral> charLiteral_ptr = dynamic_pointer_cast<charLiteral>(literal);
            string var_name = var_def_ptr->get_variableName();
            char char_literal = charLiteral_ptr->get_charLiteral();
            shared_ptr<Char> char_ptr = shared_ptr<Char>(new Char(char_literal));
            memory_ptr->set_memory(var_name, char_ptr);
        }
        else if (dynamic_pointer_cast<boolLiteral>(literal)){
            shared_ptr<boolLiteral> boolLiteral_ptr = dynamic_pointer_cast<boolLiteral>(literal);
            string var_name = var_def_ptr->get_variableName();
            bool bool_literal = boolLiteral_ptr->get_boolLiteral();
            shared_ptr<Bool> bool_ptr = shared_ptr<Bool>(new Bool(bool_literal));
            memory_ptr->set_memory(var_name, bool_ptr);
        }
        else if(dynamic_pointer_cast <decimalLiteral>(literal)){
            shared_ptr<decimalLiteral> decimalLiteral_ptr = dynamic_pointer_cast<decimalLiteral>(literal);
            string var_name = var_def_ptr->get_variableName();
            string decimal_literal = decimalLiteral_ptr->get_decimalLiteral();
            shared_ptr<Num> decimal_ptr = shared_ptr<Num>(new Num(decimal_literal));
            memory_ptr->set_memory(var_name, decimal_ptr);
        }
        else{
            cerr << "Error, unknown literal type" << endl;
            exit(1);
        }
    }
}
void add_yield(string graph_name, vector<shared_ptr<Memory> > memory_containers){
    /* 
        Add the specific yield to the operator return
    */
}
shared_ptr<stackElement> Path:: addElementToStack(shared_ptr<AstNode> ast_node){
    /* Create a stack elem and based on the type of the ast node set the type of the stack element
    again, the type of the stack element can be binary, unary, literal, or graph call
    */
   if(dynamic_pointer_cast<binaryExpression>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "binary";
       stack_elem->ast_node = ast_node;
       computation_stack.push(stack_elem);
       return stack_elem;
   }
   else if(dynamic_pointer_cast<unaryExpression>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "unary";
       stack_elem->ast_node = ast_node;
       computation_stack.push(stack_elem);
        return stack_elem;
   }
   else if(dynamic_pointer_cast<stringLiteral>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "string";
       stack_elem->ast_node = ast_node;
       computation_stack.push(stack_elem);
        return stack_elem;
   }
   else if (dynamic_pointer_cast<integerLiteral>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "num";
       stack_elem->ast_node = ast_node;
       computation_stack.push(stack_elem);
       return stack_elem;
   }
   else if(dynamic_pointer_cast<decimalLiteral>(ast_node)){
         shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
         stack_elem->type = "num";
         stack_elem->ast_node = ast_node;
         computation_stack.push(stack_elem);
         return stack_elem;
    }
    else if(dynamic_pointer_cast<boolLiteral>(ast_node)){
         shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
         stack_elem->type = "bool";
         stack_elem->ast_node = ast_node;
         computation_stack.push(stack_elem);
         return stack_elem;

   }
   else if (dynamic_pointer_cast<charLiteral>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "char";
       stack_elem->ast_node = ast_node;
       computation_stack.push(stack_elem);
       return stack_elem;
   }
   else if(dynamic_pointer_cast<assignmentExpression>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "assignment";
       stack_elem->ast_node = ast_node;
       computation_stack.push(stack_elem);
       return stack_elem;
   }
    // Also maybe another expression itself 
   else if (dynamic_pointer_cast<expression>(ast_node)){
        shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
        stack_elem->type = "expression";
        stack_elem->ast_node = ast_node;
        computation_stack.push(stack_elem);
        return stack_elem;
    }
    // Can also be a variable type 
    else if(dynamic_pointer_cast<variable>(ast_node)){
        shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
        stack_elem->type = "variable";
        stack_elem->ast_node = ast_node;
        computation_stack.push(stack_elem);
        return stack_elem;
    }

    else{
        cerr << "Error, unknown ast node type" << endl;
        exit(1);
    }

}

shared_ptr<Memory> Path:: evaluateBinaryExpressionPrimitive(shared_ptr<Memory> left, shared_ptr<Memory> right, string operations){
// Here we will check first to see if it is a primitive type, by dynamic casting, then if it is, 
// Evaluate the operation, as of now the primitives are Int(Soon to be Num type), Char and Bool
    if(dynamic_pointer_cast<Num>(left)){
        // This is an int 
        shared_ptr<Num> left_int = dynamic_pointer_cast<Num>(left);
        // If the right is not an int, the an error will be thrown
        if(!dynamic_pointer_cast<Num>(right)){
            cerr << "Error, trying to add a non integer to an integer" << endl;
            exit(1);
        }
        shared_ptr<Num> right_int = dynamic_pointer_cast<Num>(right);
        // Now we will evaluate the operation
        if(operations == "+"){
            return left_int->add(right_int);
        }
        else if(operations == "-"){
            return left_int->sub(right_int);
        }
        // else if(operations == "*"){ Soon to be implemented
        //     return left_int->multiply(right_int);
        // }
        // else if(operations == "/"){
        //     return left_int->divide(right_int);
        // }
        // else if(operations == "%"){
        //     return left_int->modulo(right_int);
        // }
        else if(operations == "=="){
            return left_int->equal(right_int);
        }
        else if(operations == "!="){
            return left_int->not_equal(right_int);
        }
        else if(operations == "<"){
            return left_int->less(right_int);
        }
        else if(operations == ">"){
            return left_int->greater(right_int);
        }
        else if(operations == "<="){
            return left_int->less_equal(right_int);
        }
        else if(operations == ">="){
            return left_int->greater_equal(right_int);
        }
        else{
            cerr << "Error, unknown operation" << endl;
            exit(1);
        }
    }
    else if(dynamic_pointer_cast<Bool>(left)){
        // This is a bool
        shared_ptr<Bool> left_bool = dynamic_pointer_cast<Bool>(left);
        if(!dynamic_pointer_cast<Bool>(right)){
            cerr << "Error, trying to add a non boolean to a boolean" << endl;
            exit(1);
        }
        shared_ptr<Bool> right_bool = dynamic_pointer_cast<Bool>(right);
        if(operations == "&&"){
            return left_bool->and_op(right_bool);
        }
        else if(operations == "||"){
            return left_bool->or_op(right_bool);
        }
        else{
            cerr << "Error, unknown operation" << endl;
            exit(1);
        }   
    }         
    else if(dynamic_pointer_cast<Char>(left)){
        // This is a char
        shared_ptr<Char> left_char = dynamic_pointer_cast<Char>(left);
        if(!dynamic_pointer_cast<Char>(right)){
            cerr << "Error, trying to add a non char to a char" << endl;
            exit(1);
        }
        shared_ptr<Char> right_char = dynamic_pointer_cast<Char>(right);
        if(operations == "=="){
            return left_char->equal(right_char);
        }
        else if(operations == "!="){
            return left_char->not_equal(right_char);
        }
        else if(operations == "<"){
            return left_char->less(right_char);
        }
        else if(operations == ">"){
            return left_char->greater(right_char);
        }
        else if(operations == "<="){
            return left_char->less_equal(right_char);
        }
        else if(operations == ">="){
            return left_char->greater_equal(right_char);
        }
        else{
            cerr << "Error, unknown operation" << endl;
            exit(1);
        }
    }
    else{
        return nullptr;
    }

}
shared_ptr<Memory> Path :: evaluateExpression(){
// For every stack element evaluate and then pop. 
    while(!computation_stack.empty()){
        cout<<"Computation stack size: "<<computation_stack.size()<<endl;
        shared_ptr<stackElement> stack_elem = computation_stack.top();
        // If the memory container is not set, then we will evaluate the expression

        if(stack_elem->stack_elem_ptr_ls.size() && stack_elem->stack_elem_ptr_ls[0]->memory_container && computation_stack.size() == 1){
            // If this is the final condition, then we will return the memory container
            // And pop the stack element
            cout << "Returning the memory container" << endl;
            computation_stack.pop();
            return stack_elem->stack_elem_ptr_ls[0]->memory_container;
        }
        else if(stack_elem->type == "expression"){
            // Evaluate the expression
            // Set the vector of stack elements to the next pointer Ast Node
            cout << "Evaluating the expression" << endl;
            if(stack_elem->stack_elem_ptr_ls.size() == 0){
                // If the stack element has not been evaluated, then we will add the next element to the stack
                shared_ptr<expression> expression_ptr = dynamic_pointer_cast<expression>(stack_elem->ast_node);
                shared_ptr<AstNode> pointing_expression = expression_ptr->get_expression();
                // As of now we have either a binary expression, unary expression, literal. or an assignment expression
                shared_ptr<stackElement> next_stack_elem = addElementToStack(pointing_expression);
                stack_elem->stack_elem_ptr_ls.push_back(next_stack_elem);// Now this elements value is determined by the next stack element

            }
            else{
                // If the stack element has been evaluated, then we will set the memory container and pop the stack element
                stack_elem->memory_container = stack_elem->stack_elem_ptr_ls[0]->memory_container;
                computation_stack.pop();
            }   
        }        
        else if(stack_elem->type == "binary"){
            cout<< "Evaluating the binary expression" << endl;
            // Evaluate the binary expression
            shared_ptr<binaryExpression> binaryExpression_ptr = dynamic_pointer_cast<binaryExpression>(stack_elem->ast_node);
            // If the left and right side have not been added
            if(stack_elem->stack_elem_ptr_ls.size() == 0){
                // Get the left and right side of the binary expression, and push them to the stack
                shared_ptr<AstNode> left = binaryExpression_ptr->get_leftSide();
                shared_ptr<AstNode> right = binaryExpression_ptr->get_rightSide();
                shared_ptr<stackElement> left_stack_elem = addElementToStack(left);
                shared_ptr<stackElement> right_stack_elem = addElementToStack(right);
                stack_elem->stack_elem_ptr_ls.push_back(left_stack_elem);
                stack_elem->stack_elem_ptr_ls.push_back(right_stack_elem);                
            }   
            else{     
                /* In this case the left and right side have been added and evaluated, thus 
                we will evaluate the binary expression. Note that for nums, boolean and other primitive types
                we don't add a new path for the operations we just evaluate them. 
                */
               // Get the left and right memory container 
               shared_ptr<Memory> left_memory = stack_elem->stack_elem_ptr_ls[0]->memory_container;
               shared_ptr<Memory> right_memory = stack_elem->stack_elem_ptr_ls[1]->memory_container;
                // Get the operation
                string operation = binaryExpression_ptr->get_operation();
                // If the memory is a primitive then we will evaluate the operation
                shared_ptr<Memory> result = evaluateBinaryExpressionPrimitive(left_memory, right_memory, operation);
                if(result){
                    // If the result is not null, then we will set the memory container and pop the stack element
                    stack_elem->memory_container = result;
                    computation_stack.pop();
                }  
                else{  
                    // If the result is null(not a primitive type), then we know that the left and right side are not primitive types
                    // So we have to add a new path to the operator, and yield the current path
                    // TODO :- Add the path to the operator
                }
            }   
        }
        // variable case 
        else if(stack_elem->type == "variable"){
            cout << "Evaluating the variable" << endl;
            // Get the variable name
            shared_ptr<variable> variable_ptr = dynamic_pointer_cast<variable>(stack_elem->ast_node);
            string variable_name = variable_ptr->get_variableName();
            // Get the memory container
            shared_ptr<Memory> memory = memory_ptr->get_memory(variable_name);
            // Set the memory container
            stack_elem->memory_container = memory;
            computation_stack.pop();
        }
        // Assignment case
        else if(stack_elem->type == "assignment"){
            cout << "Evaluating the assignment" << endl;
            // If we are first evaluating the assignment, then we will add the expression to the stack

            if (stack_elem->stack_elem_ptr_ls.size() == 0){
                shared_ptr<assignmentExpression> assignmentExpression_ptr = dynamic_pointer_cast<assignmentExpression>(stack_elem->ast_node);
                // Get the variable name
                string variable_name = assignmentExpression_ptr->get_variableName();
                // Get the expression
                shared_ptr<AstNode> expression = assignmentExpression_ptr->get_expression();
                // Add the expression to the stack
                shared_ptr<stackElement> expression_stack_elem = addElementToStack(expression);
                stack_elem->stack_elem_ptr_ls.push_back(expression_stack_elem);
            }
            else{
                // If the expression has been evaluated, then we will set the memory container
                shared_ptr<Memory> expression_memory = stack_elem->stack_elem_ptr_ls[0]->memory_container;
                shared_ptr<assignmentExpression> assignmentExpression_ptr = dynamic_pointer_cast<assignmentExpression>(stack_elem->ast_node);
                // Get the variable name
                string variable_name = assignmentExpression_ptr->get_variableName();
                // Set the memory container
                memory_ptr->set_memory(variable_name, expression_memory);
                // The assignment should return the value of the variable
                stack_elem->memory_container = expression_memory;
                computation_stack.pop();   
            }
 
        }
        // Now we will go to literal types 
        // else if(stack_elem->type == "string"){
        //     cout << "Evaluating the string" << endl;
        //     shared_ptr<stringLiteral> stringLiteral_ptr = dynamic_pointer_cast<stringLiteral>(stack_elem->ast_node);
        //     string string_literal = stringLiteral_ptr->get_stringLiteral();
        //     shared_ptr<String> string_ptr = shared_ptr<String>(new String(string_literal));
        //     stack_elem->memory_container = string_ptr;
        //     computation_stack.pop();
        // }
        else if(stack_elem->type == "num"){
            cout << "Evaluating the Number" << endl;
            // Dynamically cast to see if the number is a decimal or an integer
            if(dynamic_pointer_cast<integerLiteral>(stack_elem->ast_node)){
                shared_ptr<integerLiteral> integerLiteral_ptr = dynamic_pointer_cast<integerLiteral>(stack_elem->ast_node);
                string integer_literal = integerLiteral_ptr->get_integerLiteral();
                shared_ptr<Num> int_ptr = shared_ptr<Num>(new Num(integer_literal));
                stack_elem->memory_container = int_ptr;
                computation_stack.pop();
            } 
            else if(dynamic_pointer_cast<decimalLiteral>(stack_elem->ast_node)){
                shared_ptr<decimalLiteral> decimalLiteral_ptr = dynamic_pointer_cast<decimalLiteral>(stack_elem->ast_node);
                string decimal_literal = decimalLiteral_ptr->get_decimalLiteral();
                cout<<"Decimal Literal: "<<decimal_literal<<endl;
                shared_ptr<Num> decimal_ptr = shared_ptr<Num>(new Num(decimal_literal));
                stack_elem->memory_container = decimal_ptr;
                computation_stack.pop();
            }   
            else{ 
                cerr << "Error, unknown number type" << endl;
                exit(1);
            }
        }
        else if(stack_elem->type == "char"){
            cout << "Evaluating the char" << endl;
            shared_ptr<charLiteral> charLiteral_ptr = dynamic_pointer_cast<charLiteral>(stack_elem->ast_node);
            char char_literal = charLiteral_ptr->get_charLiteral();
            shared_ptr<Char> char_ptr = shared_ptr<Char>(new Char(char_literal));
            stack_elem->memory_container = char_ptr;
            computation_stack.pop();
        }
        else{
            cerr << "Error, unknown stack element type" << endl;
            exit(1);
        }
    }
}

int Path :: run(){

    // Here we will define the path logic, the path logic is the main logic for running graph objects
    if(current_time == 0){
        // Set the memory container
        memory_ptr = shared_ptr<Memory>(new Memory);
        // traverse the memory ast and set the memory container
        shared_ptr<AstNode> memory = graph_ptr->get_memory_def();
        set_memory(memory);

        // Set the memory log
        memory_log[0] = vector<string>();
        current_time++;
    }

    while(current_time < max_time){
        // Get graph_nodes transitions for the current node 
        vector<transition> transitions = graph_ptr->get_transitions(current_node);
        cout<< "Current Node: " << current_node << endl;
        bool has_transitioned = false;
        for(int i = current_transition; i < transitions.size(); i++){
            bool valid = true;
            transition transition = transitions[i];
            bool all_conditions = true;

            for(int c = current_condition; c < transition.conditions.size(); c++){
                // We are setting the expression to the stack if the stack is empty(no previous yield)
                if(computation_stack.empty()){
                    shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
                    stack_elem->type = "expression"; // We will set the type to expression
                    stack_elem->ast_node = transition.conditions[c]; // The ast node will be the first condition
                    computation_stack.push(stack_elem);
                }


                shared_ptr<expression> condition_ptr = dynamic_pointer_cast<expression>(transition.conditions[c]);
                // Evaluate the condition it will return a boolean memory container
                shared_ptr<Memory> condition_result = evaluateExpression();
                if(!condition_result){
                    return 0; // Yields to Pending(if normal yield would be 0), thus the path will be set to pending until a specific condition or operation is met
                }
                // Dynamic cast the memory container to a boolean, if it is not a boolean then the condition is invalid
                if(!dynamic_pointer_cast<Bool>(condition_result)){
                    valid = false;
                    cerr << "Error, condition is not a boolean" << endl;
                }
                else{
                    shared_ptr<Bool> bool_condition = dynamic_pointer_cast<Bool>(condition_result);
                    cout<< "Condition: " << bool_condition->get_val() << endl;
                    if(!bool_condition->get_val()){
                        valid = false;
                        all_conditions = false;
                        // If the condition is false, then we will break out of the loop
                        break;
                    }
                }
                current_condition++;
        }

        if(all_conditions){
            for(int o = current_operation; o < transition.operations.size(); o++){
                // We are setting the expression to the stack if the stack is empty(no previous yield)
                if(computation_stack.empty()){
                    shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
                    stack_elem->type = "expression"; // We will set the type to expression
                    stack_elem->ast_node = transition.operations[o]; // The ast node will be the first condition
                    computation_stack.push(stack_elem);
                }

                shared_ptr<expression> operation_ptr = dynamic_pointer_cast<expression>(transition.operations[o]);
                // Evaluate the operation
                shared_ptr<Memory> operation_result = evaluateExpression();
                if(!operation_result){
                    return 0; // Yields to Pending(if normal yield would be 0), thus the path will be set to pending until a specific condition or operation is met
                }
                // If the operation result is a memory container, then we will set the memory container
                current_operation++;
            }
            // Set the current node to the to node
            current_node = transition.toNode;
            current_time++;
            current_condition = 0;
            current_operation = 0;
            current_transition = 0;
            has_transitioned = true;
            break;
        }

        current_transition++;
    }
    // If the current node is the same as the previous node, then we will return 0. As the path is stuck
    // In the case where the current node is an accept node, then we will return 1
    if(graph_ptr->is_accept_node(current_node) && !has_transitioned){
        cout << "Accept Node" << endl;
        cout<< current_node << endl;
        // Let us assuke there is a symbol called currentVal in the memory container and it is an int 
        shared_ptr<Num> currentVal = dynamic_pointer_cast<Num>(memory_ptr->get_memory("a"));
        cout << "Val: " << currentVal->to_string(1)<<endl;
        return 1;
    }
    else if(!has_transitioned){
        cout << "Rejected" << endl;
        return 0;
    }


    }
}