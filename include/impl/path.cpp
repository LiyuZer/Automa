#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include "../core/operator.h"
#include "../core/path.h"
#include "../core/path.h"
#include "../core/memory.h"
#include "../core/graph.h"
#include "../../grammar/ast/ast_node.h"
#include "../typesdef/num.h"
#include "../typesdef/bool.h"
#include "../typesdef/char.h"
#include "../typesdef/list.h"


/* 
Evaluate the expression
As of not an expression can be a assignment, binary expression, unary expression, or a literal(term)
Conditions cannot be assignment expressions

The evaluation of the conditions of a transition will be done in the following way:-
    There will be a condition evaluation stack that will be used to evaluate the conditions
    Why is this the case? The reason is because at any point the condition might call a new graph 
    and thus a new path has to be generated by the operator. This results in a yield by the current path. 
    
    The operator will then run the current path, take  the output memory container and 
    then take the old path out of the pending stack and run it with this new memory container.

    This is a typical stack element:-
    {
        memory_container : memory_container
        type : ""  (Binary, Unary, Literal. Graph call)
        Stack_elem_ptr_ls : a vector of shared ptr to stack elements that may nor may not be evaluated 
    }
    This way we keep a track of the evaluation of the conditions. And we can backtrack if we need to, and start 
    evaluating the conditions again.

Note all operations are expressed by graphs, for example adding two ints(soon to be num) will be a graph,
the graph being an element of the memory container will be called and the two memory containers will be passed to it.
The graph will then return a new memory container with the result of the operation.
Simple as that.

These are the mapping for the operations to symbols. 
+ -> add
- -> subtract
* -> multiply
/ -> divide
% -> modulo
== -> equal
!= -> not_equal
< -> less
> -> greater
<= -> less_equal
>= -> greater_equal
&& -> and
|| -> or
! -> not
We will call these graphs from the memory_container(they are all graphs in the memory container)
*/

void Path :: set_memory(shared_ptr<AstNode> memory){ 
    // Loop through the memory defintions and set the memory container
    shared_ptr<memoryDef> memoryDef_ptr = dynamic_pointer_cast<memoryDef>(memory);
    vector<shared_ptr<AstNode> > variableDefinitions = memoryDef_ptr->get_variableDefinitions();
    // Create a memory container if it is not already set
    if(!(this->memory_ptr)){
        memory_ptr = shared_ptr<Memory>(new Memory);
    }
    for(auto var_def : variableDefinitions){
        shared_ptr var_def_ptr = dynamic_pointer_cast<variableDefintions>(var_def);
        string var_name = var_def_ptr->get_variableName();
        shared_ptr<AstNode> elem = var_def_ptr->get_elem();        

    
        // Note that the elem is an expression node
        // All we have to do is evaluate the expression and set the memory container
        // So push the expression on the stack and evaluate it
        // We do this if the memory ofr the var name is not already set(for cases where we inputted arguments to the memory)
        if(memory_ptr->get_memory(var_name)){
            continue;
        }
        shared_ptr<stackElement> stack_elem = addElementToStack(elem);
        shared_ptr<Memory> output = evaluateExpression();
        
        memory_ptr->set_memory(var_name, output);
    }
}
void Path:: addArgument(vector<shared_ptr<Memory>> arg, shared_ptr<Graph> graph_ptr){
    /* 
        Add the argument to the memory container
    */
    // Loop through the memoryDef of the graph and then add the arg based on that order 
    shared_ptr<memoryDef> memoryDef_ptr = dynamic_pointer_cast<memoryDef>(graph_ptr->get_memory_def());
    vector<shared_ptr<AstNode> > variableDefinitions = memoryDef_ptr->get_variableDefinitions();
    shared_ptr<Memory> memory_container = shared_ptr<Memory>(new Memory);
    for(int i = 0; i < arg.size(); i++){
        //We don't need to evaluate the expression, we just need to add the argument to the memory container
        shared_ptr<Memory> elem = arg[i];
        shared_ptr<variableDefintions> var_def_ptr = dynamic_pointer_cast<variableDefintions>(variableDefinitions[i]);
        string var_name = var_def_ptr->get_variableName();
        memory_container->set_memory(var_name, elem);
    }
    this->memory_ptr = memory_container;

}
void add_yield(string graph_name, vector<shared_ptr<Memory> > memory_containers){
    /* 
        Add the specific yield to the operator return
    */
   // We will 
}
shared_ptr<stackElement> Path:: addElementToStack(shared_ptr<AstNode> ast_node){
    /* Create a stack elem and based on the type of the ast node set the type of the stack element
    again, the type of the stack element can be binary, unary, literal, or graph call
    */
   if(dynamic_pointer_cast<binaryExpression>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "binary";
       stack_elem->ast_node = ast_node;
       computation_stack->push_back(stack_elem);
       return stack_elem;
   }
   else if(dynamic_pointer_cast<unaryExpression>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "unary";
       stack_elem->ast_node = ast_node;
       computation_stack->push_back(stack_elem);
        return stack_elem;
   }
   else if(dynamic_pointer_cast<stringLiteral>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "string";
       stack_elem->ast_node = ast_node;
       computation_stack->push_back(stack_elem);
        return stack_elem;
   }
   else if (dynamic_pointer_cast<integerLiteral>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "num";
       stack_elem->ast_node = ast_node;
       computation_stack->push_back(stack_elem);
       return stack_elem;
   }
   else if(dynamic_pointer_cast<decimalLiteral>(ast_node)){
         shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
         stack_elem->type = "num";
         stack_elem->ast_node = ast_node;
         computation_stack->push_back(stack_elem);
         return stack_elem;
    }
    else if(dynamic_pointer_cast<boolLiteral>(ast_node)){
         shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
         stack_elem->type = "bool";
         stack_elem->ast_node = ast_node;
         computation_stack->push_back(stack_elem);
         return stack_elem;

   }
   else if (dynamic_pointer_cast<charLiteral>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "char";
       stack_elem->ast_node = ast_node;
       computation_stack->push_back(stack_elem);
       return stack_elem;
   }
   else if(dynamic_pointer_cast<assignmentExpression>(ast_node)){
       shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
       stack_elem->type = "assignment";
       stack_elem->ast_node = ast_node;
       computation_stack->push_back(stack_elem);
       return stack_elem;
   }
    // Also maybe another expression itself 
   else if (dynamic_pointer_cast<expression>(ast_node)){
        shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
        stack_elem->type = "expression";
        stack_elem->ast_node = ast_node;
        computation_stack->push_back(stack_elem);
        return stack_elem;
    }
    // Can also be a variable type 
    else if(dynamic_pointer_cast<variable>(ast_node)){
        shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
        stack_elem->type = "variable";
        stack_elem->ast_node = ast_node;
        computation_stack->push_back(stack_elem);
        return stack_elem;
    }
    // Can also be a list type
    else if(dynamic_pointer_cast<list>(ast_node)){
        shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
        stack_elem->type = "list";
        stack_elem->ast_node = ast_node;
        computation_stack->push_back(stack_elem);
        return stack_elem;
    }
    // graph call 
    else if(dynamic_pointer_cast<graphCall>(ast_node)){
        shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
        stack_elem->type = "graph";
        stack_elem->ast_node = ast_node;
        computation_stack->push_back(stack_elem);
        return stack_elem;
    }
    else{
        cerr << "Error, unknown ast node type" << endl;
        exit(1);
    }
}

shared_ptr<Memory> Path:: evaluateBinaryExpressionPrimitive(shared_ptr<Memory>& left, shared_ptr<Memory>& right, string& operations){
// Here we will check first to see if it is a primitive type, by dynamic casting, then if it is, 
// Evaluate the operation, as of now the primitives are Int(Soon to be Num type), Char and Bool
    if(dynamic_pointer_cast<Num>(left)){
        // This is an int 
        shared_ptr<Num> left_int = dynamic_pointer_cast<Num>(left);
        // If the right is not an int, the an error will be thrown
        if(!dynamic_pointer_cast<Num>(right)){
            cerr << "Error, trying to add a non integer to an integer" << endl;
            exit(1);
        }
        shared_ptr<Num> right_int = dynamic_pointer_cast<Num>(right);
        // Now we will evaluate the operation
        if(operations == "+"){
            return left_int->add(right_int);
        }
        else if(operations == "-"){
            return left_int->sub(right_int);
        }
        // else if(operations == "*"){ Soon to be implemented
        //     return left_int->multiply(right_int);
        // }
        // else if(operations == "/"){
        //     return left_int->divide(right_int);
        // }
        // else if(operations == "%"){
        //     return left_int->modulo(right_int);
        // }
        else if(operations == "=="){
            return left_int->equal(right_int);
        }
        else if(operations == "!="){
            return left_int->not_equal(right_int);
        }
        else if(operations == "<"){
            return left_int->less(right_int);
        }
        else if(operations == ">"){
            return left_int->greater(right_int);
        }
        else if(operations == "<="){
            return left_int->less_equal(right_int);
        }
        else if(operations == ">="){
            return left_int->greater_equal(right_int);
        }
        else{
            cerr << "Error, unknown operation" << endl;
            exit(1);
        }
    }
    else if(dynamic_pointer_cast<Bool>(left)){
        // This is a bool
        shared_ptr<Bool> left_bool = dynamic_pointer_cast<Bool>(left);
        if(!dynamic_pointer_cast<Bool>(right)){
            cerr << "Error, trying to add a non boolean to a boolean" << endl;
            exit(1);
        }
        shared_ptr<Bool> right_bool = dynamic_pointer_cast<Bool>(right);
        if(operations == "&&"){
            return left_bool->and_op(right_bool);
        }
        else if(operations == "||"){
            return left_bool->or_op(right_bool);
        }
        else{
            cerr << "Error, unknown operation" << endl;
            exit(1);
        }   
    }         
    else if(dynamic_pointer_cast<Char>(left)){
        // This is a char
        shared_ptr<Char> left_char = dynamic_pointer_cast<Char>(left);
        if(!dynamic_pointer_cast<Char>(right)){
            cerr << "Error, trying to add a non char to a char" << endl;
            exit(1);
        }
        shared_ptr<Char> right_char = dynamic_pointer_cast<Char>(right);
        if(operations == "=="){
            return left_char->equal(right_char);
        }
        else if(operations == "!="){
            return left_char->not_equal(right_char);
        }
        else if(operations == "<"){
            return left_char->less(right_char);
        }
        else if(operations == ">"){
            return left_char->greater(right_char);
        }
        else if(operations == "<="){
            return left_char->less_equal(right_char);
        }
        else if(operations == ">="){
            return left_char->greater_equal(right_char);
        }
        else{
            cerr << "Error, unknown operation" << endl;
            exit(1);
        }
    }
    else{
        return nullptr;
    }

}



shared_ptr< vector<shared_ptr<stackElement> > Path :: initializeStack(shared_ptr<AstNode> expression_node){
    /* 
    In this case the stack has not been found in the cache, thus we will initialize the stack 
    */ 

   // We will add all the elements tot he stack 
   bool pushed = true;

   while(pushed){
    // If there is a push, then we will continue to push
    
   }

}
void Path :: update_computation_stack(shared_ptr<Memory> output){
    /*
        This function will update the computation stack by setting the memory container of the top stack element 
        then decrementing the execution pointer.
    */

    shared_ptr<stackElement> stack_elem = computation_stack->back();
    stack_elem->memory_container = output;
    execution_ptr--;
}
shared_ptr<operatorReturn> Path :: run(){
    // Here we will define the path logic, the path logic is the main logic for running graph objects
    if(current_time == 0){

        // traverse the memory ast and set the memory container
        shared_ptr<AstNode> memory = graph_ptr->get_memory_def();
        set_memory(memory);

        // Set the memory log
        memory_log[0] = vector<string>();
        current_time++;
    }

    while(current_time < max_time){
        // Get graph_nodes transitions for the current node 
        vector<transition> transitions = graph_ptr->get_transitions(current_node);
        bool has_transitioned = false;
        for(int i = current_transition; i < transitions.size(); i++){
            bool valid = true;
            transition transition = transitions[i];
            bool all_conditions = true;

            for(int c = current_condition; c < transition.conditions.size(); c++){
                // We are setting the expression to the stack if the stack is empty(no previous yield)
                if(computation_stack.empty()){
                    shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
                    stack_elem->type = "expression"; // We will set the type to expression
                    stack_elem->ast_node = transition.conditions[c]; // The ast node will be the first condition
                    computation_stack.push(stack_elem);
                }


                shared_ptr<expression> condition_ptr = dynamic_pointer_cast<expression>(transition.conditions[c]);
                // Evaluate the condition it will return a boolean memory container
                shared_ptr<Memory> condition_result = evaluateExpression();
                if(!condition_result){
                    return nullptr; // Yields to Pending(if normal yield would be 0), thus the path will be set to pending until a specific condition or operation is met
                }
                // Dynamic cast the memory container to a boolean, if it is not a boolean then the condition is invalid
                if(!dynamic_pointer_cast<Bool>(condition_result)){
                    valid = false;
                    cerr << "Error, condition is not a boolean" << endl;
                    exit(1);
                }
                else{
                    shared_ptr<Bool> bool_condition = dynamic_pointer_cast<Bool>(condition_result);
                    if(!bool_condition->get_val()){
                        valid = false;
                        all_conditions = false;
                        // If the condition is false, then we will break out of the loop
                        break;
                    }
                }
                current_condition++;
        }

        if(all_conditions){
            for(int o = current_operation; o < transition.operations.size(); o++){
                // We are setting the expression to the stack if the stack is empty(no previous yield)
                if(computation_stack.empty()){
                    shared_ptr<stackElement> stack_elem = shared_ptr<stackElement>(new stackElement);
                    stack_elem->type = "expression"; // We will set the type to expression
                    stack_elem->ast_node = transition.operations[o]; // The ast node will be the first condition
                    computation_stack.push(stack_elem);
                }

                shared_ptr<expression> operation_ptr = dynamic_pointer_cast<expression>(transition.operations[o]);
                
                auto start = std::chrono::high_resolution_clock::now();
                // Evaluate the operation
                shared_ptr<Memory> operation_result = evaluateExpression();
                auto end = std::chrono::high_resolution_clock::now();
                auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);

                std::cout << "Execution took: " << duration.count() << " ns\n";

                // Case where the operation result is a memory container(must be a graph call)
                if(!operation_result){
                    // This means that the operation is a graph call, and the path will yield
                    return operator_return;
                }

                // If the operation result is a memory container, then we will set the memory container
                current_operation++;
            }
            // Set the current node to the to node
            current_node = transition.toNode;
            current_time++;
            current_condition = 0;
            current_operation = 0;
            current_transition = 0;
            has_transitioned = true;
            break;
        }

        current_transition++;
    }
    // If the current node is the same as the previous node, then we will return 0. As the path is stuck
    // In the case where the current node is an accept node, then we will return 1
    if(graph_ptr->is_accept_node(current_node) && !has_transitioned){
        //Create a operator return
        operator_return = shared_ptr<operatorReturn>(new operatorReturn);
        operator_return->status = 1;
        // Now if an accept routine is defined then we will run it and return the container there
        if(graph_ptr->get_accept()){
            shared_ptr<AstNode> accept_routine = graph_ptr->get_accept();
            //Dynamically cast it to an accept node 
            shared_ptr<accept> accept_routine_ptr = dynamic_pointer_cast<accept>(accept_routine);

            // We will take the expression that the accept node points to and evaluate it
            if(accept_routine_ptr->get_expression()){
                shared_ptr<stackElement> stack_elem = addElementToStack(accept_routine_ptr->get_expression());
                shared_ptr<Memory> output = evaluateExpression();
                operator_return->memory_containers.push_back(output);
                // Just for deubggin n let us assume the memory contianer is a num
                cout << "Graph Id: " << id << endl;
                cout << "Memory type: " << output->get_type() << endl;
                cout<< "Memory value: " << dynamic_pointer_cast<Num>(output)->to_string(50) << endl;
            }
            
            return operator_return;
        }
        return nullptr; // TODO change this to the memory container
    }
    else if(!has_transitioned){
        cout << "Rejected" << endl;
        return nullptr; // TODO change this to the memory container
    }


    }
}