#include <unordered_map>
#include <memory>
#include <string>
#include <vector>
#include <unordered_map>
#include "graph.h"
#include "memory.h"
#include <stack>
#pragma once
/*

Here we define a path obj. 

Path objects have 4 main parts:-
    Current state -> the current node of transaction
    ID -> a unique id generated by the operator and given to the 
    path obj 
    timer(to be implemented) -> a count down timer, when this times is finished 
    the graph yields back to the operator. 
    Memory container -> a ptr to the memory container for executions
    Memory log(to be implemented) -> a memory log of all changed memory parts, 
    to be used during acceptance rejection.



A path is an abstraction for computation it can be accepted, rejected or in a pending 
state. It is called by an operator, set with the memory container, it runs independently and 
yields back to the operator, very similar to limited time context switching 
by the operating system between processes. 

*/

using namespace std;
/*
   This is a typical stack element:-
    {
        memory_container : memory_container
        type : ""  (Binary, Unary, Literal. Graph call)
        Stack_elem_ptr_ls : a vector of shared ptr to stack elements that may nor may not be evaluated 
    }
*/
struct stackElement{
    char status=0;// In special cases we will have a status
    shared_ptr<Memory> memory_container;
    string type;
    vector<shared_ptr<stackElement> > stack_elem_ptr_ls;
    shared_ptr<AstNode> ast_node;
};
/*
Here we define the return value from the operator
*/
struct operatorReturn{
    /*
    This will have two values 
    */
    int status; 
    string graph_name;
    vector<shared_ptr<Memory>> memory_containers; // The argument to be passed to the graph
};

class Path{
    private:
    int id;
    int id_to_return;
    string current_node;
    shared_ptr<Graph> graph_ptr;
    int max_time;
    int current_time;
    shared_ptr<Memory> memory_ptr=nullptr;
    unordered_map<int, vector<string> > memory_log;
    vector<shared_ptr<stackElement>>* computation_stack;
    unordered_map<string, shared_ptr<vector<shared_ptr<stackElement>>> > cache_stack;// A cache for the stacks, we will use this for computation
    int execution_ptr = 0;// The current execution pointer of the stack

    int condition_ptr = 0;
    int operation_ptr = 0;
    int accept_ptr = 0;
    
    int current_condition = 0; // The current condition being evaluated
    int current_operation = 0; // The current operation being evaluated
    int current_transition = 0; // The current transition being evaluated
    shared_ptr<operatorReturn> operator_return; // The return value from the operator

    shared_ptr<Memory> input; // The input memory container by the operator(if yielded or the path is created as a result of a graph call)
    
    // This will store the current yield(if there is any)
    operatorReturn yield;
    public:
        Path(int id, string current_node, int max_time, int current_time, shared_ptr<Graph> graph_ptr, int id_to_return)
        : id(id), current_node(current_node), max_time(max_time), current_time(current_time), graph_ptr(graph_ptr), id_to_return(id_to_return){}

        shared_ptr<operatorReturn> run();
        void add_yield();
        shared_ptr<Memory> evaluateExpression();
        shared_ptr<Memory> evaluateBinaryExpressionPrimitive(shared_ptr<Memory>& left, shared_ptr<Memory>& right, string& operations);
        shared_ptr< vector<shared_ptr<stackElement> >> initializeStack(shared_ptr<AstNode> expression_node);
        shared_ptr<stackElement> addElementToStack(shared_ptr<AstNode> ast_node);
        void addArgument(vector<shared_ptr<Memory>> arg, shared_ptr<Graph> graph_ptr);
        void set_memory(shared_ptr<AstNode> memory);
        void update_computation_stack(shared_ptr<Memory> output);
        void set_input(shared_ptr<Memory> input){
            this->input = input;
        }
        int get_id(){
            return id;
        }
        shared_ptr<Memory> get_memory(){
            return memory_ptr;
        }
        shared_ptr<Graph> get_graph(){
            return graph_ptr;
        }
        void set_memory(shared_ptr<Memory> memory){
            memory_ptr = memory;
        }
        void add_symbol(string symbol){// Add a memory symbol to the memory container
            memory_ptr->set_memory(symbol, shared_ptr<Memory>(new Memory));
        }
        shared_ptr<Memory> get_memory_symbol(string symbol){// Get a memory symbol from the memory container
            return memory_ptr->get_memory(symbol);
        }
        void change_symbol(string symbol, shared_ptr<Memory> memory){// Change a memory symbol in the memory container
            memory_ptr->set_memory(symbol, memory);
        }
        int get_id_to_return(){
            return id_to_return;
        }   

};